
【完全版】戸建購入希望者情報 生成プロンプト（Claude CLI用）
実行概要
URICOサイトの戸建購入希望者情報を、詳細なマッチング条件付きで生成する。既存のdata/house/area/およびdata/house/station/配下のJSONファイルを読み込み、各購入希望者に完全なプロフィールと希望条件を追加して上書き保存する。

タスク
既存の戸建購入希望者JSONファイルを読み込み、以下のフィールドを追加・更新してファイルを上書き保存せよ。

データ構造定義
入力データ（現在の形式）
[
  {
    "timing": "購入時期",
    "id": "旧形式の簡易ID"
  }
]
出力データ（新形式）
[
  {
    "id": "KO-00001",
    "family": "夫婦+子供2人",
    "age": "38歳",
    "occupation": "会社員（一般職）",
    "timing": "6ヶ月以内",
    "method": "住宅ローン",
    "reason": "子供の学区",
    "ng": "特になし",
    "buildingAge": "築15年まで",
    "layout": "3LDK〜5LDK",
    "landArea": "151〜300㎡",
    "walkingDistance": "駅徒歩10分以内"
  }
]

フィールド生成ルール
1. id（購入希望者ID）
* 形式: KO-{5桁の連番}（KO = Kodate（戸建））
* 例: KO-00001, KO-00234, KO-12345
* ルール:
    * エリアごとにユニークなIDを付与
    * 全国で重複しないようグローバルカウンターで管理
    * 生成時に既存IDがあれば新規採番

2. family（家族構成）
選択肢
* 単身
* 夫婦
* 夫婦+子供1人
* 夫婦+子供2人
* 夫婦+子供3人
* 三世代同居希望
* 親との同居予定
比率
{
  "単身": 10,
  "夫婦": 15,
  "夫婦+子供1人": 25,
  "夫婦+子供2人": 30,
  "夫婦+子供3人": 10,
  "三世代同居希望": 5,
  "親との同居予定": 5
}

3. age（年齢）
家族構成別の年齢範囲
{
  "単身": [25, 45],
  "夫婦": [30, 55],
  "夫婦+子供1人": [30, 50],
  "夫婦+子供2人": [30, 50],
  "夫婦+子供3人": [30, 50],
  "三世代同居希望": [35, 60],
  "親との同居予定": [35, 60]
}
表記形式
* "{年齢}歳" 例: "35歳", "42歳"

4. occupation（職業）
データソース
必須: prompts/occupation_list.jsonファイルを読み込み、このリストから職業を選択すること
年齢制限付き職業
* ID 49（パート・アルバイト）: 57歳以上のみ選択可能
* ID 50（無職）: 67歳以上のみ選択可能
選択ロジック
function selectOccupation(age, family) {
  // occupation_list.jsonを読み込む
  const occupationList = readJSON("prompts/occupation_list.json");
  
  // 年齢によるフィルタリング
  let availableOccupations = occupationList.filter(occ => {
    if (occ.id === 49 && age < 57) return false; // パート・アルバイト
    if (occ.id === 50 && age < 67) return false; // 無職
    return true;
  });
  
  // 家族構成が「夫婦+子供3人」「三世代同居希望」の場合は安定収入職業を優先（70%の確率）
  const stableIncomeIds = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 16, 17, 28]; // 会社員、公務員、医師、IT系、経営者等
  if ((family.includes("子供3人") || family.includes("三世代")) && Math.random() < 0.7) {
    availableOccupations = availableOccupations.filter(occ => stableIncomeIds.includes(occ.id));
  }
  
  // ランダム選択
  return availableOccupations[Math.floor(Math.random() * availableOccupations.length)].name;
}
職業別比率の目安
* 会社員系: 35%
* 公務員・教員系: 15%
* 医療・福祉系: 12%
* IT・技術系: 10%
* 経営・自営業系: 10%
* その他: 18%

5. timing（購入時期）
選択肢と比率
{
  "即時": 20,
  "3ヶ月以内": 25,
  "6ヶ月以内": 30,
  "1年以内": 15,
  "良い物件があれば": 10
}

6. method（購入方法）
選択肢と基本比率
{
  "現金購入": 15,
  "住宅ローン": 60,
  "親族の援助あり": 15,
  "買い替え": 10
}
職業による調整
function selectMethod(occupation) {
  // 高所得職業（医師、歯科医師、経営者・役員等）
  const highIncomeOccupations = ["医師", "歯科医師", "経営者・役員", "不動産業"];
  if (highIncomeOccupations.includes(occupation)) {
    // 現金購入: 40%, 住宅ローン: 40%, 親族の援助: 15%, 買い替え: 5%
    const rand = Math.random();
    if (rand < 0.40) return "現金購入";
    if (rand < 0.80) return "住宅ローン";
    if (rand < 0.95) return "親族の援助あり";
    return "買い替え";
  }
  
  // 安定職業（公務員、教員、大手会社員等）
  const stableOccupations = ["公務員（国家公務員）", "公務員（地方公務員）", "教員（小・中・高校）", "会社員（管理職）"];
  if (stableOccupations.includes(occupation)) {
    // 住宅ローン: 70%, 親族の援助: 20%, 現金購入: 5%, 買い替え: 5%
    const rand = Math.random();
    if (rand < 0.70) return "住宅ローン";
    if (rand < 0.90) return "親族の援助あり";
    if (rand < 0.95) return "現金購入";
    return "買い替え";
  }
  
  // デフォルト（基本比率）
  const rand = Math.random();
  if (rand < 0.15) return "現金購入";
  if (rand < 0.75) return "住宅ローン";
  if (rand < 0.90) return "親族の援助あり";
  return "買い替え";
}

7. reason（購入理由）
選択肢（均等分布）
[
  "通勤の利便性",
  "子供の学区",
  "実家の近く",
  "広い家が欲しい",
  "庭付きの家が欲しい",
  "戸建に住みたい",
  "資産形成",
  "両親との同居",
  "静かな環境",
  "駐車場が必要",
  "ペットを飼いたい",
  "リモートワーク環境"
]
比率: 各8.3%程度（均等分布）

8. ng（NG条件）
選択肢と比率
{
  "特になし": 50,
  "再建築不可": 5,
  "旧耐震基準": 6,
  "接道不良": 5,
  "事故物件": 6,
  "隣地との境界未確定": 5,
  "傾斜地": 5,
  "水害リスクエリア": 6,
  "墓地や葬儀場の近く": 5,
  "大規模な修繕が必要": 7
}

9. buildingAge（希望築年数）
選択肢と比率（完全均等）
{
  "築15年まで": 25,
  "築16〜25年": 25,
  "築26〜35年": 25,
  "築36年以上": 25
}
表記形式
* "築15年まで"
* "築16〜25年"
* "築26〜35年"
* "築36年以上"

10. layout（希望間取り）
選択肢と基本比率
{
  "特に希望なし": 50,
  "2LDKまで": 10,
  "3LDK〜5LDK": 30,
  "5LDK以上": 10
}
家族構成による整合性調整
function selectLayout(family, baseRatio) {
  // 家族構成と間取りの整合性
  const layoutMapping = {
    "単身": ["2LDKまで", "特に希望なし"],
    "夫婦": ["2LDKまで", "3LDK〜5LDK", "特に希望なし"],
    "夫婦+子供1人": ["3LDK〜5LDK", "特に希望なし"],
    "夫婦+子供2人": ["3LDK〜5LDK", "特に希望なし"],
    "夫婦+子供3人": ["3LDK〜5LDK", "5LDK以上"],
    "三世代同居希望": ["5LDK以上", "3LDK〜5LDK"],
    "親との同居予定": ["3LDK〜5LDK", "5LDK以上"]
  };
  
  const preferredLayouts = layoutMapping[family];
  
  // 基本比率に従うが、家族構成に合わない間取りは除外
  // 50%の確率で「特に希望なし」、残り50%で家族構成に適した間取りから選択
  if (preferredLayouts.includes("特に希望なし") && Math.random() < 0.5) {
    return "特に希望なし";
  }
  
  const filteredLayouts = preferredLayouts.filter(l => l !== "特に希望なし");
  return filteredLayouts[Math.floor(Math.random() * filteredLayouts.length)];
}

11. landArea（希望土地面積）
選択肢と基本比率
{
  "〜50㎡": 10,
  "51〜150㎡": 30,
  "151〜300㎡": 40,
  "301㎡以上": 20
}
家族構成による整合性調整
function selectLandArea(family, reason) {
  // 家族構成と土地面積の整合性
  if (family === "単身" || family === "夫婦") {
    // 小規模優先: 〜50㎡(20%), 51〜150㎡(50%), 151〜300㎡(25%), 301㎡以上(5%)
    const rand = Math.random();
    if (rand < 0.20) return "〜50㎡";
    if (rand < 0.70) return "51〜150㎡";
    if (rand < 0.95) return "151〜300㎡";
    return "301㎡以上";
  }
  
  if (family.includes("子供3人") || family.includes("三世代") || family.includes("同居")) {
    // 大規模優先: 〜50㎡(0%), 51〜150㎡(10%), 151〜300㎡(50%), 301㎡以上(40%)
    const rand = Math.random();
    if (rand < 0.10) return "51〜150㎡";
    if (rand < 0.60) return "151〜300㎡";
    return "301㎡以上";
  }
  
  // 購入理由による調整
  if (reason === "庭付きの家が欲しい" || reason === "ペットを飼いたい") {
    // 広めを優先: 151㎡以上を80%
    const rand = Math.random();
    if (rand < 0.80) {
      return Math.random() < 0.7 ? "151〜300㎡" : "301㎡以上";
    }
  }
  
  // デフォルト（基本比率）
  const rand = Math.random();
  if (rand < 0.10) return "〜50㎡";
  if (rand < 0.40) return "51〜150㎡";
  if (rand < 0.80) return "151〜300㎡";
  return "301㎡以上";
}

12. walkingDistance（駅徒歩）
選択肢と比率（完全均等）
{
  "駅徒歩10分以内": 25,
  "駅徒歩11〜15分": 25,
  "駅徒歩16〜20分": 25,
  "駅徒歩21分以上": 25
}
購入理由による調整
function selectWalkingDistance(reason) {
  // 「通勤の利便性」の場合は駅近を優先
  if (reason === "通勤の利便性") {
    // 駅徒歩10分以内: 60%, 11〜15分: 30%, 16分以上: 10%
    const rand = Math.random();
    if (rand < 0.60) return "駅徒歩10分以内";
    if (rand < 0.90) return "駅徒歩11〜15分";
    return Math.random() < 0.5 ? "駅徒歩16〜20分" : "駅徒歩21分以上";
  }
  
  // デフォルト（完全均等）
  const rand = Math.random();
  if (rand < 0.25) return "駅徒歩10分以内";
  if (rand < 0.50) return "駅徒歩11〜15分";
  if (rand < 0.75) return "駅徒歩16〜20分";
  return "駅徒歩21分以上";
}

生成フロー（完全版）
Step 1: ファイル読み込み
// 1. occupation_list.jsonを読み込む
const occupationList = readJSON("prompts/occupation_list.json");

// 2. 対象ファイルリストを取得
const areaFiles = glob("data/house/area/**/*.json");
const stationFiles = glob("data/house/station/**/*.json");
const allFiles = [...areaFiles, ...stationFiles];

// 3. グローバルIDカウンターを初期化
let globalIdCounter = 1;
Step 2: 各ファイルを処理
for (const filePath of allFiles) {
  // 既存データを読み込む
  const existingData = readJSON(filePath);
  const totalBuyers = existingData.length;
  
  // 新しいデータ配列を作成
  const newBuyers = [];
  
  // 比率計算（各条件の件数を事前計算）
  const buildingAgeDistribution = calculateDistribution(totalBuyers, [25, 25, 25, 25]); // 各25%
  const layoutDistribution = calculateDistribution(totalBuyers, [50, 10, 30, 10]); // 特に希望なし50%, 2LDKまで10%, 3-5LDK30%, 5LDK以上10%
  const landAreaDistribution = calculateDistribution(totalBuyers, [10, 30, 40, 20]); // 〜50㎡10%, 51-150㎡30%, 151-300㎡40%, 301㎡以上20%
  const walkingDistanceDistribution = calculateDistribution(totalBuyers, [25, 25, 25, 25]); // 各25%
  
  // 配列をシャッフル（ランダム配置）
  const buildingAgeOptions = shuffleArray(expandByDistribution(["築15年まで", "築16〜25年", "築26〜35年", "築36年以上"], buildingAgeDistribution));
  const layoutOptions = shuffleArray(expandByDistribution(["特に希望なし", "2LDKまで", "3LDK〜5LDK", "5LDK以上"], layoutDistribution));
  const landAreaOptions = shuffleArray(expandByDistribution(["〜50㎡", "51〜150㎡", "151〜300㎡", "301㎡以上"], landAreaDistribution));
  const walkingDistanceOptions = shuffleArray(expandByDistribution(["駅徒歩10分以内", "駅徒歩11〜15分", "駅徒歩16〜20分", "駅徒歩21分以上"], walkingDistanceDistribution));
  
  // 各購入希望者を生成
  for (let i = 0; i < totalBuyers; i++) {
    // 1. 家族構成を選択
    const family = selectFamilyByRatio();
    
    // 2. 年齢を生成
    const age = generateAge(family);
    
    // 3. 職業を選択（年齢制限を考慮）
    const occupation = selectOccupation(age, family, occupationList);
    
    // 4. 購入時期を選択
    const timing = selectTimingByRatio();
    
    // 5. 購入方法を選択（職業による調整）
    const method = selectMethod(occupation);
    
    // 6. 購入理由を選択
    const reason = selectReasonByRatio();
    
    // 7. NG条件を選択
    const ng = selectNGByRatio();
    
    // 8. 希望築年数を割り当て（事前計算済み配列から取得）
    const buildingAge = buildingAgeOptions[i];
    
    // 9. 希望間取りを割り当て（家族構成との整合性チェック）
    let layout = layoutOptions[i];
    if (!isLayoutCompatible(family, layout)) {
      layout = adjustLayoutForFamily(family);
    }
    
    // 10. 希望土地面積を割り当て（家族構成・購入理由との整合性チェック）
    let landArea = landAreaOptions[i];
    if (!isLandAreaCompatible(family, landArea)) {
      landArea = adjustLandAreaForFamily(family, reason);
    }
    
    // 11. 駅徒歩を割り当て（購入理由による調整）
    let walkingDistance = walkingDistanceOptions[i];
    if (reason === "通勤の利便性" && Math.random() < 0.6) {
      walkingDistance = "駅徒歩10分以内";
    }
    
    // 12. IDを生成
    const id = `KO-${String(globalIdCounter).padStart(5, '0')}`;
    globalIdCounter++;
    
    // 購入希望者オブジェクトを作成
    newBuyers.push({
      id,
      family,
      age: `${age}歳`,
      occupation,
      timing,
      method,
      reason,
      ng,
      buildingAge,
      layout,
      landArea,
      walkingDistance
    });
  }
  
  // ファイルに上書き保存
  writeJSON(filePath, newBuyers);
  console.log(`処理完了: ${filePath} (${totalBuyers}件)`);
}

バリデーションルール
必須チェック項目
1. 年齢制限の遵守
function validateAgeRestriction(buyer) {
  const age = parseInt(buyer.age);
  
  if (buyer.occupation === "パート・アルバイト" && age < 57) {
    throw new Error(`パート・アルバイトは57歳以上のみ: ${buyer.id} (${age}歳)`);
  }
  
  if (buyer.occupation === "無職" && age < 67) {
    throw new Error(`無職は67歳以上のみ: ${buyer.id} (${age}歳)`);
  }
}
2. 比率の確認
function validateDistribution(buyers, field, expectedRatios) {
  const counts = {};
  buyers.forEach(b => {
    counts[b[field]] = (counts[b[field]] || 0) + 1;
  });
  
  const total = buyers.length;
  for (const [value, expectedRatio] of Object.entries(expectedRatios)) {
    const actualRatio = (counts[value] || 0) / total * 100;
    const diff = Math.abs(actualRatio - expectedRatio);
    
    if (diff > 5) { // ±5%以内の誤差を許容
      console.warn(`${field}の比率がずれています: ${value} - 期待値${expectedRatio}%, 実際${actualRatio.toFixed(1)}%`);
    }
  }
}
3. 家族構成と間取りの整合性
function validateLayoutCompatibility(buyers) {
  const incompatible = buyers.filter(b => {
    if ((b.family === "夫婦+子供3人" || b.family.includes("三世代")) && b.layout === "2LDKまで") {
      return true;
    }
    return false;
  });
  
  if (incompatible.length > 0) {
    console.warn(`間取りと家族構成の不整合: ${incompatible.length}件`);
  }
}
4. ID重複チェック
function validateUniqueIds(allBuyers) {
  const ids = allBuyers.map(b => b.id);
  const uniqueIds = new Set(ids);
  
  if (ids.length !== uniqueIds.size) {
    throw new Error(`ID重複が検出されました: ${ids.length}件中${uniqueIds.size}件がユニーク`);
  }
}

出力例
エリアファイルの例: data/house/area/奈良県/奈良市.json
[
  {
    "id": "KO-00001",
    "family": "夫婦+子供2人",
    "age": "38歳",
    "occupation": "会社員（一般職）",
    "timing": "6ヶ月以内",
    "method": "住宅ローン",
    "reason": "子供の学区",
    "ng": "特になし",
    "buildingAge": "築15年まで",
    "layout": "3LDK〜5LDK",
    "landArea": "151〜300㎡",
    "walkingDistance": "駅徒歩10分以内"
  },
  {
    "id": "KO-00002",
    "family": "夫婦",
    "age": "45歳",
    "occupation": "公務員（地方公務員）",
    "timing": "1年以内",
    "method": "住宅ローン",
    "reason": "静かな環境",
    "ng": "旧耐震基準",
    "buildingAge": "築16〜25年",
    "layout": "特に希望なし",
    "landArea": "51〜150㎡",
    "walkingDistance": "駅徒歩16〜20分"
  },
  {
    "id": "KO-00003",
    "family": "単身",
    "age": "32歳",
    "occupation": "ITエンジニア",
    "timing": "3ヶ月以内",
    "method": "住宅ローン",
    "reason": "リモートワーク環境",
    "ng": "特になし",
    "buildingAge": "築26〜35年",
    "layout": "2LDKまで",
    "landArea": "51〜150㎡",
    "walkingDistance": "駅徒歩11〜15分"
  },
  {
    "id": "KO-00004",
    "family": "夫婦+子供3人",
    "age": "42歳",
    "occupation": "医師",
    "timing": "即時",
    "method": "現金購入",
    "reason": "広い家が欲しい",
    "ng": "特になし",
    "buildingAge": "築15年まで",
    "layout": "5LDK以上",
    "landArea": "301㎡以上",
    "walkingDistance": "駅徒歩21分以上"
  },
  {
    "id": "KO-00005",
    "family": "三世代同居希望",
    "age": "55歳",
    "occupation": "経営者・役員",
    "timing": "良い物件があれば",
    "method": "現金購入",
    "reason": "両親との同居",
    "ng": "旧耐震基準",
    "buildingAge": "築36年以上",
    "layout": "5LDK以上",
    "landArea": "301㎡以上",
    "walkingDistance": "駅徒歩16〜20分"
  },
  {
    "id": "KO-00006",
    "family": "夫婦",
    "age": "58歳",
    "occupation": "パート・アルバイト",
    "timing": "1年以内",
    "method": "親族の援助あり",
    "reason": "実家の近く",
    "ng": "特になし",
    "buildingAge": "築26〜35年",
    "layout": "特に希望なし",
    "landArea": "51〜150㎡",
    "walkingDistance": "駅徒歩11〜15分"
  },
  {
    "id": "KO-00007",
    "family": "夫婦",
    "age": "70歳",
    "occupation": "無職",
    "timing": "6ヶ月以内",
    "method": "現金購入",
    "reason": "静かな環境",
    "ng": "傾斜地",
    "buildingAge": "築15年まで",
    "layout": "2LDKまで",
    "landArea": "51〜150㎡",
    "walkingDistance": "駅徒歩10分以内"
  }
]

実装の注意事項
1. 並列処理の推奨
* ファイル数が多いため、Claude CLIの並列処理機能を活用すること
* エリアファイルと駅ファイルを同時に処理して効率化
2. エラーハンドリング
* ファイル読み込みエラー時は該当ファイルをスキップしてログに記録
* データ生成エラー時は該当購入希望者をスキップして続行
* 最終的に処理結果サマリーを出力
3. ログ出力
処理開始: 2024-01-24 10:00:00
対象ファイル数: 1,234件
---
処理中: data/house/area/奈良県/奈良市.json (42件) ✓
処理中: data/house/area/奈良県/生駒市.json (28件) ✓
処理中: data/house/station/JR西日本/大和路線/奈良駅.json (35件) ✓
...
---
処理完了: 1,234ファイル / 45,678件の購入希望者
エラー: 0件
警告: 3件（比率のずれ）
処理時間: 15分32秒
4. バックアップ
* 処理前に既存データのバックアップを作成すること
* data/house_backup_{timestamp}/にコピー

実行コマンド（想定）
# Claude CLIで実行
claude --project urico-kansai generate-house-buyers.js

# または
npm run generate:house-buyers

完了条件
以下がすべて満たされた場合、タスク完了とする:
1. ✅ すべてのエリアファイル・駅ファイルが処理済み
2. ✅ 各購入希望者に12個のフィールドがすべて入力済み
3. ✅ ID重複なし
4. ✅ 年齢制限（パート・アルバイト、無職）が遵守されている
5. ✅ 各フィールドの比率が±5%以内の誤差
6. ✅ 家族構成と間取り・土地面積の整合性が確保されている
7. ✅ すべてのファイルが正常にJSON形式で保存されている
